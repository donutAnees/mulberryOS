# Interrupts
## Generic Interrupt Controller
A Generic Interrupt Controller (GIC) takes interrupts from peripherals, prioritizes them, and delivers them to the appropriate processor core. The GIC is the standard interrupt controller for Arm Cortex-A and Arm Cortex-R profile processors.

### Interrupt types
The GIC can deal with four different types of interrupt sources:
- Shared Peripheral Interrupt (SPI). Peripheral interrupts that can be delivered to any connected core.

- Private Peripheral Interrupt (PPI). Peripheral interrupts that are private to one core. An example of a PPI is an interrupt from the Generic Timer.

- Software Generated Interrupt (SGI). SGIs are typically used for inter-processor communication and are generated by a write to an SGI register in the GIC.

- Locality-specific Peripheral Interrupt (LPI). LPIs were first introduced in GICv3 and have a very different programing model to the other three types of interrupt. 

### INTID 
Each interrupt source is identified by an ID number, which is referred to as an INTID

1. SGIs - [0 - 15]
2. PPIs - [16 - 31 && 1056 - 1119]
3. SPIs - [32 - 1019 && 4096 - 5119]
4. Special interrupt number (Used to signal special cases) - [1020 - 1023]
5. Reserved - [1024 - 8191]
6. LPIs - [8192 and greater]

### Signaling Interrupts 

1. Dedicated interrupt signal - interrupts are signaled from a peripheral to the interrupt controller using a dedicated hardware signal.

2. Message Signaled Interrupts (MSI) - interrupts are signaled by writing a specific data value to a register in interrupt controller.

**NOTE**: T_T Just realized that Raspberry Pi Zero 2 W doesn have a GIC but rather uses the broadcom interrupt controller. Will have this section here since I already wrote it.

## Interrupt Controller - Broadcom BCM2836/7 Interrupt Controller

The BCM2836/7 SoC uses a **cascaded interrupt architecture** with two distinct interrupt controllers:

1. **Local Interrupt Controller** - Per-CPU private interrupts (timers, mailbox, PMU)
2. **ARMCTRL (Global) Interrupt Controller** - Shared peripheral interrupts (UART, SPI, USB, etc.)

### Hardware IRQ Numbers Are Controller-Specific

Each interrupt controller has its own **hardware IRQ number (hwirq)** namespace. This means:
- Local controller hwirq 0 = CNTPSIRQ (Secure Timer)
- ARMCTRL hwirq 0 = Something completely different (a GPU peripheral)

These are NOT the same interrupt! The hardware IRQ number only has meaning within the context of its parent controller.

```
┌─────────────────────────────────────────────────────────────┐
│                    CPU Exception Entry                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              Local Interrupt Controller                     │
│                  (Base: 0x40000000)                         │
│                                                             │
│  hwirq 0: CNTPSIRQ    hwirq 4: Mailbox0   hwirq 8: GPU_FAST │
│  hwirq 1: CNTPNSIRQ   hwirq 5: Mailbox1   hwirq 9: PMU      │
│  hwirq 2: CNTHPIRQ    hwirq 6: Mailbox2                     │
│  hwirq 3: CNTVIRQ     hwirq 7: Mailbox3                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ GPU_FAST (hwirq 8) cascades to:
                              ▼
┌─────────────────────────────────────────────────────────────┐
│          ARMCTRL (Global) Interrupt Controller              │
│                  (Base: 0x3F00B200)                         │
│                                                             │
│  Bank 0 (hwirq 0-7):   ARM/local-related sources            │
│  Bank 1 (hwirq 0-31):  GPU peripheral interrupts 0-31       │
│  Bank 2 (hwirq 0-31):  GPU peripheral interrupts 32-63      │
│                                                             │
│  Examples: UART, SPI, I2C, USB, SD card, etc.               │
└─────────────────────────────────────────────────────────────┘
```

### Local Interrupt Controller
The local interrupt controller is a CPU-local interrupt management unit present in the BCM2836/7 SoC. Unlike the main interrupt controller that handles global device interrupts, the local controller manages interrupts that are private to each CPU core.

It will be handling the following interrupts:
- Per-CPU timer interrupts
- Inter-Processor Interrupts (IPIs)
- Performance Monitoring Unit (PMU) interrupts
- Fast GPU interrupts (FIQ)
- Mailbox interrupts for CPU communication

#### Supported Interrupt Types:
- Per-CPU timer interrupts
  - CNTPSIRQ (0) - Physical Secure Timer
  - CNTPNSIRQ (1) - Physical Non-Secure Timer  
  - CNTHPIRQ (2) - Hypervisor Timer
  - CNTVIRQ (3) - Virtual Timer
- Inter-Processor Interrupts (IPIs)
  - MAILBOX0-3 (4-7) - CPU mailbox interrupts
- Performance Monitoring Unit (PMU) interrupts
  - PMU_FAST (9) - Performance monitoring events
- Fast GPU interrupts (FIQ)
  - GPU_FAST (8) - Fast interrupts from GPU

#### Key Registers:
- Timer Control (0x040 + cpu * 4): Per-CPU timer interrupt enable/disable
- IRQ Pending (0x060 + cpu * 4): Per-CPU pending interrupt status
- PMU Routing (0x010/0x014): PMU interrupt routing control

### ARMCTRL (Global) Interrupt Controller

The ARMCTRL controller aggregates interrupts from GPU and SoC peripherals. It does **not** deliver interrupts directly to the CPU - instead, it asserts a signal to the Local controller's `GPU_FAST` (hwirq 8) line, which then triggers the CPU exception.

When handling a `GPU_FAST` interrupt, the local controller must read ARMCTRL's pending registers to determine which peripheral actually interrupted.

### High-Level Architecture

#### IRQ Descriptors and Virtual IRQ Numbers

The kernel maintains an array of `irq_desc` structures, one per **virtual IRQ number (virq)**. The virq is a system-wide unique identifier that the kernel uses internally, separate from the hardware IRQ numbers.

```c
struct irq_desc {
    struct irq_data    irq_data;   // Contains hwirq
    struct irq_chip    *chip;      // Controller-specific operations
    irq_flow_handler_t handle_irq; // Flow handler (level/edge/etc.)
    struct irqaction   *action;    // Registered device handlers
};
```

Each `irq_desc` links:
- **irq_data.hwirq**: The hardware IRQ number (controller-specific)
- **chip**: Pointer to the controller's mask/unmask operations
- **action**: Chain of registered device interrupt handlers

#### Current Implementation: Simple Offset Mapping

Since both controllers have overlapping hwirq namespaces (both start at 0), we need a way to map them to unique virq numbers. 

**HACK**: Currently using a simple offset + `irq_set_hwirq()`:
```
Local controller:  virq = hwirq          (virq 0-9, hwirq unchanged)
ARMCTRL:           virq = hwirq + 16     (virq 16+, irq_set_hwirq stores real hwirq)
```

`irq_set_hwirq(virq, real_hwirq)` writes the controller-local hwirq into `irq_data.hwirq` so chip callbacks (mask/unmask) use it directly without offset arithmetic.

**TODO**: The proper solution is to implement `irq_domain` (like Linux) where each controller registers a domain that handles hwirq→virq translation. This allows clean namespace separation without hardcoded offsets.

#### hwirq vs virq Mapping

`irq_init()` initialises every `irq_desc` with `hwirq = table_index`.
For the local controller this is fine (virq == hwirq), but for ARMCTRL
the two diverge. We use `irq_set_hwirq(virq, real_hwirq)` during
ARMCTRL init to fix up the stored hwirq so chip callbacks (mask/unmask)
receive the controller-local value directly.

```c
// In bcm2837_armctrl_init():
irq_set_chip_and_handler(virq, &armctrl_chip, handle_level_irq);
irq_set_hwirq(virq, hwirq);   // store real ARMCTRL hwirq
```

When `irq_domain` is implemented, the domain's `.map` callback will
set hwirq instead, and `irq_set_hwirq()` can be retired.

#### System Overview
```
Hardware IRQ Signal
        ↓
CPU Exception Vector (Assembly)
        ↓
irq_handler_c() (IRQ Subsystem Bridge)
        ↓
generic_handle_irq() (Virtual IRQ Dispatcher) 
        ↓
Flow Handler (Interrupt Policy)
        ↓
handle_irq_event() (Action Chain Processor)
        ↓
Device Handlers (Driver-specific handlers)
```

#### Key Components

**1. IRQ Descriptor (`struct irq_desc`)**
- Central data structure linking all IRQ components
- Contains hardware IRQ data, chip operations, flow handler, and device action chain
- One descriptor per virtual IRQ number

**2. IRQ Chip (`struct irq_chip`)**
- Hardware abstraction for interrupt controllers
- Provides `irq_mask()` and `irq_unmask()` operations
- Examples: BCM2837 timer chip, PMU chip, GPU chip

**3. Flow Handlers (`irq_flow_handler_t`)**
- Implement interrupt handling **policies** (not device-specific logic)
- `handle_simple_irq()`: Basic flow for simple interrupts for now
- `handle_level_irq()`: Masks and acks before handling, used for level-triggered (ARMCTRL) interrupts

**4. IRQ Actions (`struct irqaction`)**
- Device-specific interrupt handlers registered by drivers
- Supports multiple handlers per IRQ
- Linked list structure for handler chains

### Full Interrupt Flow: System Timer 3 Example

```
1. System Timer compare register matches counter
        ↓
2. BCM2837 System Timer asserts IRQ line (GPU IRQ 3)
        ↓
3. ARMCTRL latches pending bit: bank 1, bit 3 (hwirq 35)
   ARMCTRL asserts GPU_FAST output to Local controller
        ↓
4. Local controller sets bit 8 (GPU_FAST) in IRQ pending register
   CPU takes IRQ exception
        ↓
5. el1_spx_irq (exceptions.S)
   → kernel_entry (save registers)
   → bl irq_handler_c
        ↓
6. irq_handler_c() → handle_arch_irq()
   = bcm2836_arm_irqchip_handle_irq()
   Reads LOCAL_IRQ_PENDING for this CPU
   Finds bit 8 set → generic_handle_irq(8)
        ↓
7. irq_desc[8].handle_irq = bcm2837_chained_armctrl_irq
   (Chained handler — does NOT call action chain)
   Iterates all 3 ARMCTRL pending registers
   Finds bank 1 bit 3 → virq = 35 + 16 = 51
   → generic_handle_irq(51)
        ↓
8. irq_desc[51].handle_irq = handle_level_irq
   → irq_mask_and_ack(desc)        [armctrl_chip.irq_mask(hwirq=35)]
   → handle_irq_event(desc)
        ↓
9. Walks action chain for virq 51
   → bcm2837_timer_interrupt_handler(hwirq=35, dev_id=&bcm_timer)
     - Checks CS register match flag for channel 3
     - Clears match flag
     - Calls event_handler = tick_periodic_clockevent()
       → do_timer(1)                     [update jiffies]
       → set_next_event(10000, dev)      [program next tick in 10ms]
        ↓
10. handle_level_irq → enable_irq(51)   [armctrl_chip.irq_unmask(hwirq=35)]
        ↓
11. kernel_exit (restore registers, eret)
```

## Reference
- [ARM GIC Fundamentals](https://developer.arm.com/documentation/198123/0302/Arm-GIC-fundamentals)
- [Raspberry Pi BCM2826 Peripherals](https://datasheets.raspberrypi.com/bcm2836/bcm2836-peripherals.pdf)