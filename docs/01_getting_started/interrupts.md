# Interrupts
## Generic Interrupt Controller
A Generic Interrupt Controller (GIC) takes interrupts from peripherals, prioritizes them, and delivers them to the appropriate processor core. The GIC is the standard interrupt controller for Arm Cortex-A and Arm Cortex-R profile processors.

### Interrupt types
The GIC can deal with four different types of interrupt sources:
- Shared Peripheral Interrupt (SPI). Peripheral interrupts that can be delivered to any connected core.

- Private Peripheral Interrupt (PPI). Peripheral interrupts that are private to one core. An example of a PPI is an interrupt from the Generic Timer.

- Software Generated Interrupt (SGI). SGIs are typically used for inter-processor communication and are generated by a write to an SGI register in the GIC.

- Locality-specific Peripheral Interrupt (LPI). LPIs were first introduced in GICv3 and have a very different programing model to the other three types of interrupt. 

### INTID 
Each interrupt source is identified by an ID number, which is referred to as an INTID

1. SGIs - [0 - 15]
2. PPIs - [16 - 31 && 1056 - 1119]
3. SPIs - [32 - 1019 && 4096 - 5119]
4. Special interrupt number (Used to signal special cases) - [1020 - 1023]
5. Reserved - [1024 - 8191]
6. LPIs - [8192 and greater]

### Signaling Interrupts 

1. Dedicated interrupt signal - interrupts are signaled from a peripheral to the interrupt controller using a dedicated hardware signal.

2. Message Signaled Interrupts (MSI) - interrupts are signaled by writing a specific data value to a register in interrupt controller.

**NOTE**: T_T Just realized that Raspberry Pi Zero 2 W doesn have a GIC but rather uses the broadcom interrupt controller. Will have this section here since I already wrote it.

## Interrupt Controller - Broadcom BCM2836/7 Interrupt Controller

The BCM2836/7 SoC uses a **cascaded interrupt architecture** with two distinct interrupt controllers:

1. **Local Interrupt Controller** - Per-CPU private interrupts (timers, mailbox, PMU)
2. **ARMCTRL (Global) Interrupt Controller** - Shared peripheral interrupts (UART, SPI, USB, etc.)

### Hardware IRQ Numbers Are Controller-Specific

Each interrupt controller has its own **hardware IRQ number (hwirq)** namespace. This means:
- Local controller hwirq 0 = CNTPSIRQ (Secure Timer)
- ARMCTRL hwirq 0 = Something completely different (a GPU peripheral)

These are NOT the same interrupt! The hardware IRQ number only has meaning within the context of its parent controller.

```
┌─────────────────────────────────────────────────────────────┐
│                    CPU Exception Entry                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              Local Interrupt Controller                     │
│                  (Base: 0x40000000)                         │
│                                                             │
│  hwirq 0: CNTPSIRQ    hwirq 4: Mailbox0   hwirq 8: GPU_FAST │
│  hwirq 1: CNTPNSIRQ   hwirq 5: Mailbox1   hwirq 9: PMU      │
│  hwirq 2: CNTHPIRQ    hwirq 6: Mailbox2                     │
│  hwirq 3: CNTVIRQ     hwirq 7: Mailbox3                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ GPU_FAST (hwirq 8) cascades to:
                              ▼
┌─────────────────────────────────────────────────────────────┐
│          ARMCTRL (Global) Interrupt Controller              │
│                  (Base: 0x3F00B200)                         │
│                                                             │
│  Bank 0 (hwirq 0-7):   ARM/local-related sources            │
│  Bank 1 (hwirq 0-31):  GPU peripheral interrupts 0-31       │
│  Bank 2 (hwirq 0-31):  GPU peripheral interrupts 32-63      │
│                                                             │
│  Examples: UART, SPI, I2C, USB, SD card, etc.               │
└─────────────────────────────────────────────────────────────┘
```

### Local Interrupt Controller
The local interrupt controller is a CPU-local interrupt management unit present in the BCM2836/7 SoC. Unlike the main interrupt controller that handles global device interrupts, the local controller manages interrupts that are private to each CPU core.

It will be handling the following interrupts:
- Per-CPU timer interrupts
- Inter-Processor Interrupts (IPIs)
- Performance Monitoring Unit (PMU) interrupts
- Fast GPU interrupts (FIQ)
- Mailbox interrupts for CPU communication

#### Supported Interrupt Types:
- Per-CPU timer interrupts
  - CNTPSIRQ (0) - Physical Secure Timer
  - CNTPNSIRQ (1) - Physical Non-Secure Timer  
  - CNTHPIRQ (2) - Hypervisor Timer
  - CNTVIRQ (3) - Virtual Timer
- Inter-Processor Interrupts (IPIs)
  - MAILBOX0-3 (4-7) - CPU mailbox interrupts
- Performance Monitoring Unit (PMU) interrupts
  - PMU_FAST (9) - Performance monitoring events
- Fast GPU interrupts (FIQ)
  - GPU_FAST (8) - Fast interrupts from GPU

#### Key Registers:
- Timer Control (0x040 + cpu * 4): Per-CPU timer interrupt enable/disable
- IRQ Pending (0x060 + cpu * 4): Per-CPU pending interrupt status
- PMU Routing (0x010/0x014): PMU interrupt routing control

### ARMCTRL (Global) Interrupt Controller

The ARMCTRL controller aggregates interrupts from GPU and SoC peripherals. It does **not** deliver interrupts directly to the CPU - instead, it asserts a signal to the Local controller's `GPU_FAST` (hwirq 8) line, which then triggers the CPU exception.

When handling a `GPU_FAST` interrupt, the local controller must read ARMCTRL's pending registers to determine which peripheral actually interrupted.

### High-Level Architecture

#### IRQ Descriptors and Virtual IRQ Numbers

The kernel maintains an array of `irq_desc` structures, one per **virtual IRQ number (virq)**. The virq is a system-wide unique identifier that the kernel uses internally, separate from the hardware IRQ numbers.

```c
struct irq_desc {
    struct irq_data    irq_data;   // Contains hwirq
    struct irq_chip    *chip;      // Controller-specific operations
    irq_flow_handler_t handle_irq; // Flow handler (level/edge/etc.)
    struct irqaction   *action;    // Registered device handlers
};
```

Each `irq_desc` links:
- **irq_data.hwirq**: The hardware IRQ number (controller-specific)
- **chip**: Pointer to the controller's mask/unmask operations
- **action**: Chain of registered device interrupt handlers

#### Current Implementation: Simple Offset Mapping

Since both controllers have overlapping hwirq namespaces (both start at 0), we need a way to map them to unique virq numbers. 

**HACK**: Currently using a simple offset:
```
Local controller:  virq = hwirq          (virq 0-9)
ARMCTRL:           virq = hwirq + 16     (virq 16+)
```

**TODO**: The proper solution is to implement `irq_domain` (like Linux) where each controller registers a domain that handles hwirq→virq translation. This allows clean namespace separation without hardcoded offsets.

#### System Overview
```
Hardware IRQ Signal
        ↓
CPU Exception Vector (Assembly)
        ↓
irq_handler_c() (IRQ Subsystem Bridge)
        ↓
generic_handle_irq() (Virtual IRQ Dispatcher) 
        ↓
Flow Handler (Interrupt Policy)
        ↓
handle_irq_event() (Action Chain Processor)
        ↓
Device Handlers (Driver-specific handlers)
```

#### Key Components

**1. IRQ Descriptor (`struct irq_desc`)**
- Central data structure linking all IRQ components
- Contains hardware IRQ data, chip operations, flow handler, and device action chain
- One descriptor per virtual IRQ number

**2. IRQ Chip (`struct irq_chip`)**
- Hardware abstraction for interrupt controllers
- Provides `irq_mask()` and `irq_unmask()` operations
- Examples: BCM2837 timer chip, PMU chip, GPU chip

**3. Flow Handlers (`irq_flow_handler_t`)**
- Implement interrupt handling **policies** (not device-specific logic)
- `handle_simple_irq()`: Basic flow for simple interrupts for now

**4. IRQ Actions (`struct irqaction`)**
- Device-specific interrupt handlers registered by drivers
- Supports multiple handlers per IRQ
- Linked list structure for handler chains

## Reference
- [ARM GIC Fundamentals](https://developer.arm.com/documentation/198123/0302/Arm-GIC-fundamentals)
- [Raspberry Pi BCM2826 Peripherals](https://datasheets.raspberrypi.com/bcm2836/bcm2836-peripherals.pdf)