# Registers
## Register categories
Registers fall into two groups:
- System control / status registers
- Instruction-processing and exception-handling registers

On **warm reset**, **all registers are initialized to UNKNOWN**.

## General Purpose Registers (GPRs)
- 31 registers: `R0–R30`
- Access forms:
  - 64-bit: `X0–X30`
  - 32-bit: `W0–W30`

## Stack Pointer Registers
- `SP_EL0`
- `SP_EL1`
- `SP_EL2` (if EL2 implemented)
- `SP_EL3` (if EL3 implemented)

## Stack Pointer Selection Rules

Stack pointer selection depends on **current Exception Level** and **PSTATE.SP**.

### At EL0
- Always uses `SP_EL0`

### At EL1 / EL2 / EL3
- Controlled by `PSTATE.SP`:
  - `PSTATE.SP = 0` → use `SP_EL0`
  - `PSTATE.SP = 1` → use `SP_ELx`

### EL1 terminology
- **EL1t** → `SP_EL0` (thread/user stack)
- **EL1h** → `SP_EL1` (kernel/handler stack)

## SIMD and Floating-Point Registers  
The SIMD (Single Instruction, Multiple Data) and floating-point register bank comprises the 32 quadword (128-bit) SIMD and floating-point registers, V0-V31.

- 32 registers: `V0–V31` (128-bit)
- Alternate views:
  - `Q0–Q31` (128-bit)
  - `D0–D31` (64-bit)
  - `S0–S31` (32-bit)
  - `H0–H31` (16-bit)
  - `B0–B31` (8-bit)
- Can be treated as vectors of elements

## Saved Program Status Registers
The SPSR stores a snapshot of the processor state at the time an exception is taken, allowing correct restoration of execution when returning from the exception.

The SPSRs are:
- SPSR_EL1 – Used for exceptions taken to EL1 in AArch64
- SPSR_EL2 – Used for exceptions taken to EL2 in AArch64
- SPSR_EL3 – Used for exceptions taken to EL3 in AArch64

## Exception Link Registers
Holds preferred exception return addresses.

- ELR_EL1 – Used for exceptions taken to EL1
- ELR_EL2 – Used for exceptions taken to EL2
- ELR_EL3 – Used for exceptions taken to EL3

# Exceptions
## Exception generating instructions
Produce precise synchronous exceptions:
- HVC.
- SMC.
- SVC.

## Preferred Exception Return Address
When an exception is taken, the address of the instruction that caused the exception (or the next instruction in the case of a precise exception) is stored in the appropriate Exception Link Register (ELR_ELx). This allows the processor to return to the exact point of interruption when the exception is resolved.

### Asynchronous Exceptions
For asynchronous exceptions (like interrupts or SError - generated by the memory system in response to unexpected events, the instruction that triggered the event may have already been retired)
- `ELR_ELx` contains the address of the **interrupted instruction**

### Synchronous Exceptions
- For exception-generating instructions:
  - `ELR_ELx` contains the address of the **next instruction**
- For other synchronous faults:
  - `ELR_ELx` contains the address of the **faulting instruction**
- If trapped / disabled / undefined due to insufficient privilege:
  - `ELR_ELx` contains the address of the **exception-generating instruction**

## Process from Taking an Exception to Returning from an Exception
### Saving the current processor state
AArch64 has a concept of processor state known as PSTATE. PSTATE contains things like current Exception level and Arithmetical Logical Unit (ALU) flags. In AArch64, this includes:

- Condition flags
- Execution state controls
- Exception mask bits
- Access control bits
- Timing control bits
- Speculation control bits

1. Processor state (**PSTATE**) is saved into `SPSR_ELx`, this is used to restore the state on return from the exception.
2. PSTATE is updated for the target Exception Level
3. Execution branches to the exception vector
4. On return:
   - `SPSR_ELx → PSTATE`
   - `ELR_ELx → PC`
   - `ERET` resumes execution

### Routing and interrupt controllers
- Exceptions never target EL0
- Routing is controlled by the following registers:
  - `SCR_EL3` (routes to EL3)
  - `HCR_EL2` (routes to EL2)
- `SCR_EL3` overrides `HCR_EL2` on conflicts
- Exceptions routed to a higher EL **cannot be masked** by a lower EL

## Vector Tables
When taking an exception to an Exception level using AArch64, vector tables are an area of normal memory containing instructions that are then used to handle the exception.

When an exception occurs, the core needs to be able to execute the handler corresponding to that exception. The handler acts as dispatch code, identifying the cause of the exception and then calling the relevant handler code to deal with the exception. The location in memory where the handler is stored is called the exception vector. In AArch64, exception vectors are stored in exception vector tables.

Each Exception level has its own vector table, with the base address defined by its own Vector Base Address Register, VBAR_EL<x>, where <x> is 1,2, or 3. 

*Note that there is no dedicated vector table for EL0 as exceptions are never taken to EL0.*

The vectors are divided into two groups, with each group split into two sub-groups:

1. Exception from Lower EL
- Lower EL using AArch32
- Lower EL using AArch64

2. Exception from the current EL
- Exception when SP_ELx selected
- Exception when SP_EL0 selected

Therefore which vector the exception arrives at already provides information about the state of the processor at the time of the exception. 

On exception entry, the CPU always switches to SP_ELx first; kernels then decide whether to stay there or switch to another stack for real work

### Exception from the current EL while using SP_EL0

- Synchronous exception (non-External Abort): `0x000`
- Synchronous External aborts (EASE == 0): `0x000`
- IRQ / vIRQ: `0x080`
- FIQ / vFIQ: `0x100`
- SError / External Abort (EASE == 1): `0x180`

### Exception from the current EL while using SP_ELx (ELxh, x > 0)

- Synchronous exception (non-External Abort): `0x200`
- Synchronous External aborts (EASE == 0): `0x200`
- IRQ / vIRQ: `0x280`
- FIQ / vFIQ: `0x300`
- SError / External Abort (EASE == 1): `0x380`

### Exception from a lower EL and at least one lower EL is AArch64

- Synchronous exception (non-External Abort): `0x400`
- Synchronous External aborts (EASE == 0): `0x400`
- IRQ / vIRQ: `0x480`
- FIQ / vFIQ: `0x500`
- SError / External Abort (EASE == 1): `0x580`

### Exception from a lower EL and all lower ELs are AArch32

- Synchronous exception (non-External Abort): `0x600`
- Synchronous External aborts (EASE == 0): `0x600`
- IRQ / vIRQ: `0x680`
- FIQ / vFIQ: `0x700`
- SError / External Abort (EASE == 1): `0x780`


### Vector table size
Each vector slot provides **32 words**, enough for:
- Register stacking
- Dispatch to handler
- Restore state
- `ERET`

## Reference
- [ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture profile](https://developer.arm.com/documentation/ddi0487/latest)
- [AArch64 Exception Model](https://developer.arm.com/documentation/102412/latest)